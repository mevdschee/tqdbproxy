# tqdbproxy

This idea imagines a unified data layer that sits between applications and their databases, giving teams a single, intelligent gateway for MySQL and PostgreSQL. Instead of every service managing its own caching, metrics, and query instrumentation, a dedicated proxy handles these concerns centrally. It understands both wire protocols, intercepts queries, extracts optional cache‑TTL hints, normalizes SQL, and decides whether to serve results from a fast Otter cache or forward the request to the underlying database. Every query—simple or prepared—automatically produces rich execution metrics: latency, rows returned, cache hit or miss, and even the exact file and line number in the client code that triggered it. These metrics flow into go metrics and are exposed via Prometheus-compatible metrics endpoint, giving teams deep visibility into database behavior without modifying application logic.

To make adoption effortless, the system includes six client libraries—Go, PHP, and TypeScript for both MySQL and PostgreSQL. Each wraps the existing native driver, preserving its familiar interface while adding a small optional cache‑TTL parameter and automatically attaching caller metadata. The result is a consistent, language‑agnostic way to instrument database access, reduce load through caching, and gain observability across an entire stack. It turns database access into something measurable, optimizable, and shared across all services.

It should also support adding replicas, so that any query with TTL > 0 (stale responses accepted) can be served from a replica. This allows for horizontal scaling of the database layer, and can be used to reduce the load on the primary database.